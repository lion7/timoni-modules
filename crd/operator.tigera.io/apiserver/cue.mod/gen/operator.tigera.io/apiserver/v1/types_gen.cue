// Code generated by timoni. DO NOT EDIT.

//timoni:generate timoni vendor crd -f https://raw.githubusercontent.com/projectcalico/calico/refs/heads/master/charts/tigera-operator/crds/operator.tigera.io_apiservers_crd.yaml

package v1

import "strings"

// APIServer installs the Tigera API server and related resources.
// At most one instance
// of this resource is supported. It must be named "default" or
// "tigera-secure".
#APIServer: {
	// APIVersion defines the versioned schema of this representation
	// of an object.
	// Servers should convert recognized schemas to the latest
	// internal value, and
	// may reject unrecognized values.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	apiVersion: "operator.tigera.io/v1"

	// Kind is a string value representing the REST resource this
	// object represents.
	// Servers may infer this from the endpoint the client submits
	// requests to.
	// Cannot be updated.
	// In CamelCase.
	// More info:
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	kind: "APIServer"
	metadata!: {
		name!: strings.MaxRunes(253) & strings.MinRunes(1) & {
			string
		}
		namespace?: strings.MaxRunes(63) & strings.MinRunes(1) & {
			string
		}
		labels?: {
			[string]: string
		}
		annotations?: {
			[string]: string
		}
	}

	// Specification of the desired state for the Tigera API server.
	spec!: #APIServerSpec
}
#APIServerSpec: {
	// APIServerDeployment configures the calico-apiserver (or
	// tigera-apiserver in Enterprise) Deployment. If
	// used in conjunction with ControlPlaneNodeSelector or
	// ControlPlaneTolerations, then these overrides
	// take precedence.
	apiServerDeployment?: {
		// Metadata is a subset of a Kubernetes object's metadata that is
		// added to the Deployment.
		metadata?: {
			// Annotations is a map of arbitrary non-identifying metadata.
			// Each of these
			// key/value pairs are added to the object's annotations provided
			// the key does not
			// already exist in the object's annotations.
			annotations?: {
				[string]: string
			}

			// Labels is a map of string keys and values that may match
			// replicaset and
			// service selectors. Each of these key/value pairs are added to
			// the
			// object's labels provided the key does not already exist in the
			// object's labels.
			labels?: {
				[string]: string
			}
		}

		// Spec is the specification of the API server Deployment.
		spec?: {
			// MinReadySeconds is the minimum number of seconds for which a
			// newly created Deployment pod should
			// be ready without any of its container crashing, for it to be
			// considered available.
			// If specified, this overrides any minReadySeconds value that may
			// be set on the API server Deployment.
			// If omitted, the API server Deployment will use its default
			// value for minReadySeconds.
			minReadySeconds?: int32 & >=0

			// Template describes the API server Deployment pod that will be
			// created.
			template?: {
				// Metadata is a subset of a Kubernetes object's metadata that is
				// added to
				// the pod's metadata.
				metadata?: {
					// Annotations is a map of arbitrary non-identifying metadata.
					// Each of these
					// key/value pairs are added to the object's annotations provided
					// the key does not
					// already exist in the object's annotations.
					annotations?: {
						[string]: string
					}

					// Labels is a map of string keys and values that may match
					// replicaset and
					// service selectors. Each of these key/value pairs are added to
					// the
					// object's labels provided the key does not already exist in the
					// object's labels.
					labels?: {
						[string]: string
					}
				}

				// Spec is the API server Deployment's PodSpec.
				spec?: {
					// Affinity is a group of affinity scheduling rules for the API
					// server pods.
					// If specified, this overrides any affinity that may be set on
					// the API server Deployment.
					// If omitted, the API server Deployment will use its default
					// value for affinity.
					// WARNING: Please note that this field will override the default
					// API server Deployment affinity.
					affinity?: {
						// Describes node affinity scheduling rules for the pod.
						nodeAffinity?: {
							// The scheduler will prefer to schedule pods to nodes that
							// satisfy
							// the affinity expressions specified by this field, but it may
							// choose
							// a node that violates one or more of the expressions. The node
							// that is
							// most preferred is the one with the greatest sum of weights,
							// i.e.
							// for each node that meets all of the scheduling requirements
							// (resource
							// request, requiredDuringScheduling affinity expressions, etc.),
							// compute a sum by iterating through the elements of this field
							// and adding
							// "weight" to the sum if the node matches the corresponding
							// matchExpressions; the
							// node(s) with the highest sum are the most preferred.
							preferredDuringSchedulingIgnoredDuringExecution?: [...{
								// A node selector term, associated with the corresponding weight.
								preference: {
									// A list of node selector requirements by node's labels.
									matchExpressions?: [...{
										// The label key that the selector applies to.
										key: string

										// Represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
										// Lt.
										operator: string

										// An array of string values. If the operator is In or NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. If the operator is Gt or Lt,
										// the values
										// array must have a single element, which will be interpreted as
										// an integer.
										// This array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// A list of node selector requirements by node's fields.
									matchFields?: [...{
										// The label key that the selector applies to.
										key: string

										// Represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
										// Lt.
										operator: string

										// An array of string values. If the operator is In or NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. If the operator is Gt or Lt,
										// the values
										// array must have a single element, which will be interpreted as
										// an integer.
										// This array is replaced during a strategic merge patch.
										values?: [...string]
									}]
								}

								// Weight associated with matching the corresponding
								// nodeSelectorTerm, in the range 1-100.
								weight: int
							}]
							requiredDuringSchedulingIgnoredDuringExecution?: {
								// Required. A list of node selector terms. The terms are ORed.
								nodeSelectorTerms: [...{
									// A list of node selector requirements by node's labels.
									matchExpressions?: [...{
										// The label key that the selector applies to.
										key: string

										// Represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
										// Lt.
										operator: string

										// An array of string values. If the operator is In or NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. If the operator is Gt or Lt,
										// the values
										// array must have a single element, which will be interpreted as
										// an integer.
										// This array is replaced during a strategic merge patch.
										values?: [...string]
									}]

									// A list of node selector requirements by node's fields.
									matchFields?: [...{
										// The label key that the selector applies to.
										key: string

										// Represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and
										// Lt.
										operator: string

										// An array of string values. If the operator is In or NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. If the operator is Gt or Lt,
										// the values
										// array must have a single element, which will be interpreted as
										// an integer.
										// This array is replaced during a strategic merge patch.
										values?: [...string]
									}]
								}]
							}
						}

						// Describes pod affinity scheduling rules (e.g. co-locate this
						// pod in the same node, zone, etc. as some other pod(s)).
						podAffinity?: {
							// The scheduler will prefer to schedule pods to nodes that
							// satisfy
							// the affinity expressions specified by this field, but it may
							// choose
							// a node that violates one or more of the expressions. The node
							// that is
							// most preferred is the one with the greatest sum of weights,
							// i.e.
							// for each node that meets all of the scheduling requirements
							// (resource
							// request, requiredDuringScheduling affinity expressions, etc.),
							// compute a sum by iterating through the elements of this field
							// and adding
							// "weight" to the sum if the node has pods which matches the
							// corresponding podAffinityTerm; the
							// node(s) with the highest sum are the most preferred.
							preferredDuringSchedulingIgnoredDuringExecution?: [...{
								// Required. A pod affinity term, associated with the
								// corresponding weight.
								podAffinityTerm: {
									// A label query over a set of resources, in this case pods.
									// If it's null, this PodAffinityTerm matches with no Pods.
									labelSelector?: {
										// matchExpressions is a list of label selector requirements. The
										// requirements are ANDed.
										matchExpressions?: [...{
											// key is the label key that the selector applies to.
											key: string

											// operator represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists and DoesNotExist.
											operator: string

											// values is an array of string values. If the operator is In or
											// NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. This array is replaced during a
											// strategic
											// merge patch.
											values?: [...string]
										}]

										// matchLabels is a map of {key,value} pairs. A single {key,value}
										// in the matchLabels
										// map is equivalent to an element of matchExpressions, whose key
										// field is "key", the
										// operator is "In", and the values array contains only "value".
										// The requirements are ANDed.
										matchLabels?: {
											[string]: string
										}
									}

									// MatchLabelKeys is a set of pod label keys to select which pods
									// will
									// be taken into consideration. The keys are used to lookup values
									// from the
									// incoming pod labels, those key-value labels are merged with
									// `labelSelector` as `key in (value)`
									// to select the group of existing pods which pods will be taken
									// into consideration
									// for the incoming pod's pod (anti) affinity. Keys that don't
									// exist in the incoming
									// pod labels will be ignored. The default value is empty.
									// The same key is forbidden to exist in both matchLabelKeys and
									// labelSelector.
									// Also, matchLabelKeys cannot be set when labelSelector isn't
									// set.
									// This is an alpha field and requires enabling
									// MatchLabelKeysInPodAffinity feature gate.
									matchLabelKeys?: [...string]

									// MismatchLabelKeys is a set of pod label keys to select which
									// pods will
									// be taken into consideration. The keys are used to lookup values
									// from the
									// incoming pod labels, those key-value labels are merged with
									// `labelSelector` as `key notin (value)`
									// to select the group of existing pods which pods will be taken
									// into consideration
									// for the incoming pod's pod (anti) affinity. Keys that don't
									// exist in the incoming
									// pod labels will be ignored. The default value is empty.
									// The same key is forbidden to exist in both mismatchLabelKeys
									// and labelSelector.
									// Also, mismatchLabelKeys cannot be set when labelSelector isn't
									// set.
									// This is an alpha field and requires enabling
									// MatchLabelKeysInPodAffinity feature gate.
									mismatchLabelKeys?: [...string]

									// A label query over the set of namespaces that the term applies
									// to.
									// The term is applied to the union of the namespaces selected by
									// this field
									// and the ones listed in the namespaces field.
									// null selector and null or empty namespaces list means "this
									// pod's namespace".
									// An empty selector ({}) matches all namespaces.
									namespaceSelector?: {
										// matchExpressions is a list of label selector requirements. The
										// requirements are ANDed.
										matchExpressions?: [...{
											// key is the label key that the selector applies to.
											key: string

											// operator represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists and DoesNotExist.
											operator: string

											// values is an array of string values. If the operator is In or
											// NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. This array is replaced during a
											// strategic
											// merge patch.
											values?: [...string]
										}]

										// matchLabels is a map of {key,value} pairs. A single {key,value}
										// in the matchLabels
										// map is equivalent to an element of matchExpressions, whose key
										// field is "key", the
										// operator is "In", and the values array contains only "value".
										// The requirements are ANDed.
										matchLabels?: {
											[string]: string
										}
									}

									// namespaces specifies a static list of namespace names that the
									// term applies to.
									// The term is applied to the union of the namespaces listed in
									// this field
									// and the ones selected by namespaceSelector.
									// null or empty namespaces list and null namespaceSelector means
									// "this pod's namespace".
									namespaces?: [...string]

									// This pod should be co-located (affinity) or not co-located
									// (anti-affinity) with the pods matching
									// the labelSelector in the specified namespaces, where co-located
									// is defined as running on a node
									// whose value of the label with key topologyKey matches that of
									// any node on which any of the
									// selected pods is running.
									// Empty topologyKey is not allowed.
									topologyKey: string
								}

								// weight associated with matching the corresponding
								// podAffinityTerm,
								// in the range 1-100.
								weight: int
							}]

							// If the affinity requirements specified by this field are not
							// met at
							// scheduling time, the pod will not be scheduled onto the node.
							// If the affinity requirements specified by this field cease to
							// be met
							// at some point during pod execution (e.g. due to a pod label
							// update), the
							// system may or may not try to eventually evict the pod from its
							// node.
							// When there are multiple elements, the lists of nodes
							// corresponding to each
							// podAffinityTerm are intersected, i.e. all terms must be
							// satisfied.
							requiredDuringSchedulingIgnoredDuringExecution?: [...{
								// A label query over a set of resources, in this case pods.
								// If it's null, this PodAffinityTerm matches with no Pods.
								labelSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. This array is replaced during a
										// strategic
										// merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels
									// map is equivalent to an element of matchExpressions, whose key
									// field is "key", the
									// operator is "In", and the values array contains only "value".
									// The requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// MatchLabelKeys is a set of pod label keys to select which pods
								// will
								// be taken into consideration. The keys are used to lookup values
								// from the
								// incoming pod labels, those key-value labels are merged with
								// `labelSelector` as `key in (value)`
								// to select the group of existing pods which pods will be taken
								// into consideration
								// for the incoming pod's pod (anti) affinity. Keys that don't
								// exist in the incoming
								// pod labels will be ignored. The default value is empty.
								// The same key is forbidden to exist in both matchLabelKeys and
								// labelSelector.
								// Also, matchLabelKeys cannot be set when labelSelector isn't
								// set.
								// This is an alpha field and requires enabling
								// MatchLabelKeysInPodAffinity feature gate.
								matchLabelKeys?: [...string]

								// MismatchLabelKeys is a set of pod label keys to select which
								// pods will
								// be taken into consideration. The keys are used to lookup values
								// from the
								// incoming pod labels, those key-value labels are merged with
								// `labelSelector` as `key notin (value)`
								// to select the group of existing pods which pods will be taken
								// into consideration
								// for the incoming pod's pod (anti) affinity. Keys that don't
								// exist in the incoming
								// pod labels will be ignored. The default value is empty.
								// The same key is forbidden to exist in both mismatchLabelKeys
								// and labelSelector.
								// Also, mismatchLabelKeys cannot be set when labelSelector isn't
								// set.
								// This is an alpha field and requires enabling
								// MatchLabelKeysInPodAffinity feature gate.
								mismatchLabelKeys?: [...string]

								// A label query over the set of namespaces that the term applies
								// to.
								// The term is applied to the union of the namespaces selected by
								// this field
								// and the ones listed in the namespaces field.
								// null selector and null or empty namespaces list means "this
								// pod's namespace".
								// An empty selector ({}) matches all namespaces.
								namespaceSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. This array is replaced during a
										// strategic
										// merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels
									// map is equivalent to an element of matchExpressions, whose key
									// field is "key", the
									// operator is "In", and the values array contains only "value".
									// The requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// namespaces specifies a static list of namespace names that the
								// term applies to.
								// The term is applied to the union of the namespaces listed in
								// this field
								// and the ones selected by namespaceSelector.
								// null or empty namespaces list and null namespaceSelector means
								// "this pod's namespace".
								namespaces?: [...string]

								// This pod should be co-located (affinity) or not co-located
								// (anti-affinity) with the pods matching
								// the labelSelector in the specified namespaces, where co-located
								// is defined as running on a node
								// whose value of the label with key topologyKey matches that of
								// any node on which any of the
								// selected pods is running.
								// Empty topologyKey is not allowed.
								topologyKey: string
							}]
						}

						// Describes pod anti-affinity scheduling rules (e.g. avoid
						// putting this pod in the same node, zone, etc. as some other
						// pod(s)).
						podAntiAffinity?: {
							// The scheduler will prefer to schedule pods to nodes that
							// satisfy
							// the anti-affinity expressions specified by this field, but it
							// may choose
							// a node that violates one or more of the expressions. The node
							// that is
							// most preferred is the one with the greatest sum of weights,
							// i.e.
							// for each node that meets all of the scheduling requirements
							// (resource
							// request, requiredDuringScheduling anti-affinity expressions,
							// etc.),
							// compute a sum by iterating through the elements of this field
							// and adding
							// "weight" to the sum if the node has pods which matches the
							// corresponding podAffinityTerm; the
							// node(s) with the highest sum are the most preferred.
							preferredDuringSchedulingIgnoredDuringExecution?: [...{
								// Required. A pod affinity term, associated with the
								// corresponding weight.
								podAffinityTerm: {
									// A label query over a set of resources, in this case pods.
									// If it's null, this PodAffinityTerm matches with no Pods.
									labelSelector?: {
										// matchExpressions is a list of label selector requirements. The
										// requirements are ANDed.
										matchExpressions?: [...{
											// key is the label key that the selector applies to.
											key: string

											// operator represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists and DoesNotExist.
											operator: string

											// values is an array of string values. If the operator is In or
											// NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. This array is replaced during a
											// strategic
											// merge patch.
											values?: [...string]
										}]

										// matchLabels is a map of {key,value} pairs. A single {key,value}
										// in the matchLabels
										// map is equivalent to an element of matchExpressions, whose key
										// field is "key", the
										// operator is "In", and the values array contains only "value".
										// The requirements are ANDed.
										matchLabels?: {
											[string]: string
										}
									}

									// MatchLabelKeys is a set of pod label keys to select which pods
									// will
									// be taken into consideration. The keys are used to lookup values
									// from the
									// incoming pod labels, those key-value labels are merged with
									// `labelSelector` as `key in (value)`
									// to select the group of existing pods which pods will be taken
									// into consideration
									// for the incoming pod's pod (anti) affinity. Keys that don't
									// exist in the incoming
									// pod labels will be ignored. The default value is empty.
									// The same key is forbidden to exist in both matchLabelKeys and
									// labelSelector.
									// Also, matchLabelKeys cannot be set when labelSelector isn't
									// set.
									// This is an alpha field and requires enabling
									// MatchLabelKeysInPodAffinity feature gate.
									matchLabelKeys?: [...string]

									// MismatchLabelKeys is a set of pod label keys to select which
									// pods will
									// be taken into consideration. The keys are used to lookup values
									// from the
									// incoming pod labels, those key-value labels are merged with
									// `labelSelector` as `key notin (value)`
									// to select the group of existing pods which pods will be taken
									// into consideration
									// for the incoming pod's pod (anti) affinity. Keys that don't
									// exist in the incoming
									// pod labels will be ignored. The default value is empty.
									// The same key is forbidden to exist in both mismatchLabelKeys
									// and labelSelector.
									// Also, mismatchLabelKeys cannot be set when labelSelector isn't
									// set.
									// This is an alpha field and requires enabling
									// MatchLabelKeysInPodAffinity feature gate.
									mismatchLabelKeys?: [...string]

									// A label query over the set of namespaces that the term applies
									// to.
									// The term is applied to the union of the namespaces selected by
									// this field
									// and the ones listed in the namespaces field.
									// null selector and null or empty namespaces list means "this
									// pod's namespace".
									// An empty selector ({}) matches all namespaces.
									namespaceSelector?: {
										// matchExpressions is a list of label selector requirements. The
										// requirements are ANDed.
										matchExpressions?: [...{
											// key is the label key that the selector applies to.
											key: string

											// operator represents a key's relationship to a set of values.
											// Valid operators are In, NotIn, Exists and DoesNotExist.
											operator: string

											// values is an array of string values. If the operator is In or
											// NotIn,
											// the values array must be non-empty. If the operator is Exists
											// or DoesNotExist,
											// the values array must be empty. This array is replaced during a
											// strategic
											// merge patch.
											values?: [...string]
										}]

										// matchLabels is a map of {key,value} pairs. A single {key,value}
										// in the matchLabels
										// map is equivalent to an element of matchExpressions, whose key
										// field is "key", the
										// operator is "In", and the values array contains only "value".
										// The requirements are ANDed.
										matchLabels?: {
											[string]: string
										}
									}

									// namespaces specifies a static list of namespace names that the
									// term applies to.
									// The term is applied to the union of the namespaces listed in
									// this field
									// and the ones selected by namespaceSelector.
									// null or empty namespaces list and null namespaceSelector means
									// "this pod's namespace".
									namespaces?: [...string]

									// This pod should be co-located (affinity) or not co-located
									// (anti-affinity) with the pods matching
									// the labelSelector in the specified namespaces, where co-located
									// is defined as running on a node
									// whose value of the label with key topologyKey matches that of
									// any node on which any of the
									// selected pods is running.
									// Empty topologyKey is not allowed.
									topologyKey: string
								}

								// weight associated with matching the corresponding
								// podAffinityTerm,
								// in the range 1-100.
								weight: int
							}]

							// If the anti-affinity requirements specified by this field are
							// not met at
							// scheduling time, the pod will not be scheduled onto the node.
							// If the anti-affinity requirements specified by this field cease
							// to be met
							// at some point during pod execution (e.g. due to a pod label
							// update), the
							// system may or may not try to eventually evict the pod from its
							// node.
							// When there are multiple elements, the lists of nodes
							// corresponding to each
							// podAffinityTerm are intersected, i.e. all terms must be
							// satisfied.
							requiredDuringSchedulingIgnoredDuringExecution?: [...{
								// A label query over a set of resources, in this case pods.
								// If it's null, this PodAffinityTerm matches with no Pods.
								labelSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. This array is replaced during a
										// strategic
										// merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels
									// map is equivalent to an element of matchExpressions, whose key
									// field is "key", the
									// operator is "In", and the values array contains only "value".
									// The requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// MatchLabelKeys is a set of pod label keys to select which pods
								// will
								// be taken into consideration. The keys are used to lookup values
								// from the
								// incoming pod labels, those key-value labels are merged with
								// `labelSelector` as `key in (value)`
								// to select the group of existing pods which pods will be taken
								// into consideration
								// for the incoming pod's pod (anti) affinity. Keys that don't
								// exist in the incoming
								// pod labels will be ignored. The default value is empty.
								// The same key is forbidden to exist in both matchLabelKeys and
								// labelSelector.
								// Also, matchLabelKeys cannot be set when labelSelector isn't
								// set.
								// This is an alpha field and requires enabling
								// MatchLabelKeysInPodAffinity feature gate.
								matchLabelKeys?: [...string]

								// MismatchLabelKeys is a set of pod label keys to select which
								// pods will
								// be taken into consideration. The keys are used to lookup values
								// from the
								// incoming pod labels, those key-value labels are merged with
								// `labelSelector` as `key notin (value)`
								// to select the group of existing pods which pods will be taken
								// into consideration
								// for the incoming pod's pod (anti) affinity. Keys that don't
								// exist in the incoming
								// pod labels will be ignored. The default value is empty.
								// The same key is forbidden to exist in both mismatchLabelKeys
								// and labelSelector.
								// Also, mismatchLabelKeys cannot be set when labelSelector isn't
								// set.
								// This is an alpha field and requires enabling
								// MatchLabelKeysInPodAffinity feature gate.
								mismatchLabelKeys?: [...string]

								// A label query over the set of namespaces that the term applies
								// to.
								// The term is applied to the union of the namespaces selected by
								// this field
								// and the ones listed in the namespaces field.
								// null selector and null or empty namespaces list means "this
								// pod's namespace".
								// An empty selector ({}) matches all namespaces.
								namespaceSelector?: {
									// matchExpressions is a list of label selector requirements. The
									// requirements are ANDed.
									matchExpressions?: [...{
										// key is the label key that the selector applies to.
										key: string

										// operator represents a key's relationship to a set of values.
										// Valid operators are In, NotIn, Exists and DoesNotExist.
										operator: string

										// values is an array of string values. If the operator is In or
										// NotIn,
										// the values array must be non-empty. If the operator is Exists
										// or DoesNotExist,
										// the values array must be empty. This array is replaced during a
										// strategic
										// merge patch.
										values?: [...string]
									}]

									// matchLabels is a map of {key,value} pairs. A single {key,value}
									// in the matchLabels
									// map is equivalent to an element of matchExpressions, whose key
									// field is "key", the
									// operator is "In", and the values array contains only "value".
									// The requirements are ANDed.
									matchLabels?: {
										[string]: string
									}
								}

								// namespaces specifies a static list of namespace names that the
								// term applies to.
								// The term is applied to the union of the namespaces listed in
								// this field
								// and the ones selected by namespaceSelector.
								// null or empty namespaces list and null namespaceSelector means
								// "this pod's namespace".
								namespaces?: [...string]

								// This pod should be co-located (affinity) or not co-located
								// (anti-affinity) with the pods matching
								// the labelSelector in the specified namespaces, where co-located
								// is defined as running on a node
								// whose value of the label with key topologyKey matches that of
								// any node on which any of the
								// selected pods is running.
								// Empty topologyKey is not allowed.
								topologyKey: string
							}]
						}
					}

					// Containers is a list of API server containers.
					// If specified, this overrides the specified API server
					// Deployment containers.
					// If omitted, the API server Deployment will use its default
					// values for its containers.
					containers?: [...{
						// Name is an enum which identifies the API server Deployment
						// container by name.
						// Supported values are: calico-apiserver, tigera-queryserver
						name: "calico-apiserver" | "tigera-queryserver" | "calico-l7-admission-controller"

						// Resources allows customization of limits and requests for
						// compute resources such as cpu and memory.
						// If specified, this overrides the named API server Deployment
						// container's resources.
						// If omitted, the API server Deployment will use its default
						// value for this container's resources.
						// If used in conjunction with the deprecated ComponentResources,
						// then this value takes precedence.
						resources?: {
							// Claims lists the names of resources, defined in
							// spec.resourceClaims,
							// that are used by this container.
							// This is an alpha field and requires enabling the
							// DynamicResourceAllocation feature gate.
							// This field is immutable. It can only be set for containers.
							claims?: [...{
								// Name must match the name of one entry in
								// pod.spec.resourceClaims of
								// the Pod where this field is used. It makes that resource
								// available
								// inside a container.
								name: string
							}]

							// Limits describes the maximum amount of compute resources
							// allowed.
							// More info:
							// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
							limits?: {
								[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}

							// Requests describes the minimum amount of compute resources
							// required.
							// If Requests is omitted for a container, it defaults to Limits
							// if that is explicitly specified,
							// otherwise to an implementation-defined value. Requests cannot
							// exceed Limits.
							// More info:
							// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
							requests?: {
								[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}
						}
					}]

					// InitContainers is a list of API server init containers.
					// If specified, this overrides the specified API server
					// Deployment init containers.
					// If omitted, the API server Deployment will use its default
					// values for its init containers.
					initContainers?: [...{
						// Name is an enum which identifies the API server Deployment init
						// container by name.
						// Supported values are:
						// calico-apiserver-certs-key-cert-provisioner
						name: "calico-apiserver-certs-key-cert-provisioner"

						// Resources allows customization of limits and requests for
						// compute resources such as cpu and memory.
						// If specified, this overrides the named API server Deployment
						// init container's resources.
						// If omitted, the API server Deployment will use its default
						// value for this init container's resources.
						resources?: {
							// Claims lists the names of resources, defined in
							// spec.resourceClaims,
							// that are used by this container.
							// This is an alpha field and requires enabling the
							// DynamicResourceAllocation feature gate.
							// This field is immutable. It can only be set for containers.
							claims?: [...{
								// Name must match the name of one entry in
								// pod.spec.resourceClaims of
								// the Pod where this field is used. It makes that resource
								// available
								// inside a container.
								name: string
							}]

							// Limits describes the maximum amount of compute resources
							// allowed.
							// More info:
							// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
							limits?: {
								[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}

							// Requests describes the minimum amount of compute resources
							// required.
							// If Requests is omitted for a container, it defaults to Limits
							// if that is explicitly specified,
							// otherwise to an implementation-defined value. Requests cannot
							// exceed Limits.
							// More info:
							// https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
							requests?: {
								[string]: (int | string) & =~"^(\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\+|-)?(([0-9]+(\\.[0-9]*)?)|(\\.[0-9]+))))?$"
							}
						}
					}]

					// NodeSelector is the API server pod's scheduling constraints.
					// If specified, each of the key/value pairs are added to the API
					// server Deployment nodeSelector provided
					// the key does not already exist in the object's nodeSelector.
					// If used in conjunction with ControlPlaneNodeSelector, that
					// nodeSelector is set on the API server Deployment
					// and each of this field's key/value pairs are added to the API
					// server Deployment nodeSelector provided
					// the key does not already exist in the object's nodeSelector.
					// If omitted, the API server Deployment will use its default
					// value for nodeSelector.
					// WARNING: Please note that this field will modify the default
					// API server Deployment nodeSelector.
					nodeSelector?: {
						[string]: string
					}

					// Tolerations is the API server pod's tolerations.
					// If specified, this overrides any tolerations that may be set on
					// the API server Deployment.
					// If omitted, the API server Deployment will use its default
					// value for tolerations.
					// WARNING: Please note that this field will override the default
					// API server Deployment tolerations.
					tolerations?: [...{
						// Effect indicates the taint effect to match. Empty means match
						// all taint effects.
						// When specified, allowed values are NoSchedule, PreferNoSchedule
						// and NoExecute.
						effect?: string

						// Key is the taint key that the toleration applies to. Empty
						// means match all taint keys.
						// If the key is empty, operator must be Exists; this combination
						// means to match all values and all keys.
						key?: string

						// Operator represents a key's relationship to the value.
						// Valid operators are Exists and Equal. Defaults to Equal.
						// Exists is equivalent to wildcard for value, so that a pod can
						// tolerate all taints of a particular category.
						operator?: string

						// TolerationSeconds represents the period of time the toleration
						// (which must be
						// of effect NoExecute, otherwise this field is ignored) tolerates
						// the taint. By default,
						// it is not set, which means tolerate the taint forever (do not
						// evict). Zero and
						// negative values will be treated as 0 (evict immediately) by the
						// system.
						tolerationSeconds?: int

						// Value is the taint value the toleration matches to.
						// If the operator is Exists, the value should be empty, otherwise
						// just a regular string.
						value?: string
					}]

					// TopologySpreadConstraints describes how a group of pods ought
					// to spread across topology
					// domains. Scheduler will schedule pods in a way which abides by
					// the constraints.
					// All topologySpreadConstraints are ANDed.
					topologySpreadConstraints?: [...{
						// LabelSelector is used to find matching pods.
						// Pods that match this label selector are counted to determine
						// the number of pods
						// in their corresponding topology domain.
						labelSelector?: {
							// matchExpressions is a list of label selector requirements. The
							// requirements are ANDed.
							matchExpressions?: [...{
								// key is the label key that the selector applies to.
								key: string

								// operator represents a key's relationship to a set of values.
								// Valid operators are In, NotIn, Exists and DoesNotExist.
								operator: string

								// values is an array of string values. If the operator is In or
								// NotIn,
								// the values array must be non-empty. If the operator is Exists
								// or DoesNotExist,
								// the values array must be empty. This array is replaced during a
								// strategic
								// merge patch.
								values?: [...string]
							}]

							// matchLabels is a map of {key,value} pairs. A single {key,value}
							// in the matchLabels
							// map is equivalent to an element of matchExpressions, whose key
							// field is "key", the
							// operator is "In", and the values array contains only "value".
							// The requirements are ANDed.
							matchLabels?: {
								[string]: string
							}
						}

						// MatchLabelKeys is a set of pod label keys to select the pods
						// over which
						// spreading will be calculated. The keys are used to lookup
						// values from the
						// incoming pod labels, those key-value labels are ANDed with
						// labelSelector
						// to select the group of existing pods over which spreading will
						// be calculated
						// for the incoming pod. The same key is forbidden to exist in
						// both MatchLabelKeys and LabelSelector.
						// MatchLabelKeys cannot be set when LabelSelector isn't set.
						// Keys that don't exist in the incoming pod labels will
						// be ignored. A null or empty list means only match against
						// labelSelector.
						// This is a beta field and requires the
						// MatchLabelKeysInPodTopologySpread feature gate to be enabled
						// (enabled by default).
						matchLabelKeys?: [...string]

						// MaxSkew describes the degree to which pods may be unevenly
						// distributed.
						// When `whenUnsatisfiable=DoNotSchedule`, it is the maximum
						// permitted difference
						// between the number of matching pods in the target topology and
						// the global minimum.
						// The global minimum is the minimum number of matching pods in an
						// eligible domain
						// or zero if the number of eligible domains is less than
						// MinDomains.
						// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods
						// with the same
						// labelSelector spread as 2/2/1:
						// In this case, the global minimum is 1.
						// | zone1 | zone2 | zone3 |
						// | P P | P P | P |
						// - if MaxSkew is 1, incoming pod can only be scheduled to zone3
						// to become 2/2/2;
						// scheduling it onto zone1(zone2) would make the ActualSkew(3-1)
						// on zone1(zone2)
						// violate MaxSkew(1).
						// - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
						// When `whenUnsatisfiable=ScheduleAnyway`, it is used to give
						// higher precedence
						// to topologies that satisfy it.
						// It's a required field. Default value is 1 and 0 is not allowed.
						maxSkew: int

						// MinDomains indicates a minimum number of eligible domains.
						// When the number of eligible domains with matching topology keys
						// is less than minDomains,
						// Pod Topology Spread treats "global minimum" as 0, and then the
						// calculation of Skew is performed.
						// And when the number of eligible domains with matching topology
						// keys equals or greater than minDomains,
						// this value has no effect on scheduling.
						// As a result, when the number of eligible domains is less than
						// minDomains,
						// scheduler won't schedule more than maxSkew Pods to those
						// domains.
						// If value is nil, the constraint behaves as if MinDomains is
						// equal to 1.
						// Valid values are integers greater than 0.
						// When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
						// For example, in a 3-zone cluster, MaxSkew is set to 2,
						// MinDomains is set to 5 and pods with the same
						// labelSelector spread as 2/2/2:
						// | zone1 | zone2 | zone3 |
						// | P P | P P | P P |
						// The number of domains is less than 5(MinDomains), so "global
						// minimum" is treated as 0.
						// In this situation, new pod with the same labelSelector cannot
						// be scheduled,
						// because computed skew will be 3(3 - 0) if new Pod is scheduled
						// to any of the three zones,
						// it will violate MaxSkew.
						minDomains?: int

						// NodeAffinityPolicy indicates how we will treat Pod's
						// nodeAffinity/nodeSelector
						// when calculating pod topology spread skew. Options are:
						// - Honor: only nodes matching nodeAffinity/nodeSelector are
						// included in the calculations.
						// - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are
						// included in the calculations.
						// If this value is nil, the behavior is equivalent to the Honor
						// policy.
						// This is a beta-level feature default enabled by the
						// NodeInclusionPolicyInPodTopologySpread feature flag.
						nodeAffinityPolicy?: string

						// NodeTaintsPolicy indicates how we will treat node taints when
						// calculating
						// pod topology spread skew. Options are:
						// - Honor: nodes without taints, along with tainted nodes for
						// which the incoming pod
						// has a toleration, are included.
						// - Ignore: node taints are ignored. All nodes are included.
						// If this value is nil, the behavior is equivalent to the Ignore
						// policy.
						// This is a beta-level feature default enabled by the
						// NodeInclusionPolicyInPodTopologySpread feature flag.
						nodeTaintsPolicy?: string

						// TopologyKey is the key of node labels. Nodes that have a label
						// with this key
						// and identical values are considered to be in the same topology.
						// We consider each <key, value> as a "bucket", and try to put
						// balanced number
						// of pods into each bucket.
						// We define a domain as a particular instance of a topology.
						// Also, we define an eligible domain as a domain whose nodes meet
						// the requirements of
						// nodeAffinityPolicy and nodeTaintsPolicy.
						// e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a
						// domain of that topology.
						// And, if TopologyKey is "topology.kubernetes.io/zone", each zone
						// is a domain of that topology.
						// It's a required field.
						topologyKey: string

						// WhenUnsatisfiable indicates how to deal with a pod if it
						// doesn't satisfy
						// the spread constraint.
						// - DoNotSchedule (default) tells the scheduler not to schedule
						// it.
						// - ScheduleAnyway tells the scheduler to schedule the pod in any
						// location,
						// but giving higher precedence to topologies that would help
						// reduce the
						// skew.
						// A constraint is considered "Unsatisfiable" for an incoming pod
						// if and only if every possible node assignment for that pod
						// would violate
						// "MaxSkew" on some topology.
						// For example, in a 3-zone cluster, MaxSkew is set to 1, and pods
						// with the same
						// labelSelector spread as 3/1/1:
						// | zone1 | zone2 | zone3 |
						// | P P P | P | P |
						// If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can
						// only be scheduled
						// to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on
						// zone2(zone3) satisfies
						// MaxSkew(1). In other words, the cluster can still be
						// imbalanced, but scheduler
						// won't make it *more* imbalanced.
						// It's a required field.
						whenUnsatisfiable: string
					}]
				}
			}
		}
	}
}
